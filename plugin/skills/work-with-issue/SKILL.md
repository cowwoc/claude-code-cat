---
description: Execute work phases with issue-aware progress banner rendering (internal skill, invoked by /cat:work)
user-invocable: false
allowed-tools:
  - Read
  - Bash
  - Task
  - AskUserQuestion
---

# Work With Issue: Batch Phase Executor

Execute all work phases (execute, review, merge) with minimal visible output using a batch
executor pattern. Shows progress banners at phase transitions while keeping intermediate
tool calls invisible to the user.

**Architecture:** This skill is invoked by `/cat:work` after task discovery (Phase 1). It
shows Banner1 (Preparing complete), then spawns a single batch executor subagent that handles
all remaining phases internally. The batch executor outputs banners as text (visible) while
its internal subagent spawns remain invisible.

## Arguments Format

The main `/cat:work` skill invokes this with JSON-encoded arguments:

```json
{
  "issue_id": "2.1-issue-name",
  "issue_path": "/workspace/.claude/cat/issues/v2/v2.1/issue-name",
  "worktree_path": "/workspace/.worktrees/2.1-issue-name",
  "branch": "2.1-issue-name",
  "base_branch": "v2.1",
  "estimated_tokens": 45000,
  "trust": "medium",
  "verify": "changed",
  "auto_remove": true
}
```

## Progress Banners

Progress banners for all 4 phases are generated by the work_with_issue_handler and provided
in the SCRIPT OUTPUT PROGRESS BANNERS section. Individual phase banners are also provided
in the INDIVIDUAL PHASE BANNERS section for use in batch executor output.

**Phase symbols:** `○` Pending | `●` Complete | `◉` Active | `✗` Failed

**Banner pattern by phase:**
- Preparing: `◉ ○ ○ ○`
- Executing: `● ◉ ○ ○`
- Reviewing: `● ● ◉ ○`
- Merging: `● ● ● ◉`

---

## Configuration

Extract configuration from arguments:

```bash
# Parse JSON arguments
ISSUE_ID=$(echo "$ARGUMENTS" | jq -r '.issue_id')
ISSUE_PATH=$(echo "$ARGUMENTS" | jq -r '.issue_path')
WORKTREE_PATH=$(echo "$ARGUMENTS" | jq -r '.worktree_path')
BRANCH=$(echo "$ARGUMENTS" | jq -r '.branch')
BASE_BRANCH=$(echo "$ARGUMENTS" | jq -r '.base_branch')
ESTIMATED_TOKENS=$(echo "$ARGUMENTS" | jq -r '.estimated_tokens')
TRUST=$(echo "$ARGUMENTS" | jq -r '.trust')
VERIFY=$(echo "$ARGUMENTS" | jq -r '.verify')
AUTO_REMOVE=$(echo "$ARGUMENTS" | jq -r '.auto_remove')
HAS_EXISTING_WORK=$(echo "$ARGUMENTS" | jq -r '.has_existing_work // false')
EXISTING_COMMITS=$(echo "$ARGUMENTS" | jq -r '.existing_commits // 0')
```

## Step 1: Display Preparing Banner

Display the **Preparing phase** banner from SCRIPT OUTPUT PROGRESS BANNERS (`◉ ○ ○ ○` pattern).

This indicates Phase 1 (prepare) has completed and work phases are starting.

## Step 2: Spawn Batch Executor

Spawn a single batch executor subagent that handles all remaining phases internally.
This minimizes visible output - user sees only the initial spawn and banner outputs.

```
Task tool:
  description: "Execute work phases for ${ISSUE_ID}"
  subagent_type: "general-purpose"
  model: "sonnet"
  prompt: |
    Execute all work phases (execute, review, merge) for task ${ISSUE_ID}.

    ## Task Configuration
    ISSUE_ID: ${ISSUE_ID}
    ISSUE_PATH: ${TASK_PATH}
    WORKTREE_PATH: ${WORKTREE_PATH}
    BRANCH: ${BRANCH}
    BASE_BRANCH: ${BASE_BRANCH}
    ESTIMATED_TOKENS: ${ESTIMATED_TOKENS}
    TRUST: ${TRUST}
    VERIFY: ${VERIFY}
    AUTO_REMOVE: ${AUTO_REMOVE}
    HAS_EXISTING_WORK: ${HAS_EXISTING_WORK}
    EXISTING_COMMITS: ${EXISTING_COMMITS}

    ## Progress Banners (output these at phase transitions)

    **Executing banner** (output BEFORE execute phase):
    ```
    [Insert executing banner from INDIVIDUAL PHASE BANNERS]
    ```

    **Reviewing banner** (output BEFORE review phase):
    ```
    [Insert reviewing banner from INDIVIDUAL PHASE BANNERS]
    ```

    **Merging banner** (output BEFORE merge phase):
    ```
    [Insert merging banner from INDIVIDUAL PHASE BANNERS]
    ```

    ## Instructions

    Load and follow: @${CLAUDE_PLUGIN_ROOT}/skills/work-batch-executor/SKILL.md

    CRITICAL: Output each banner as plain text BEFORE starting that phase.
    This makes phase transitions visible to the user.

    If TRUST != "high", return APPROVAL_REQUIRED status after review phase
    instead of proceeding to merge. Include execution_result, review_result,
    and task goal in the response.

    Return JSON per the output contract in the skill.
```

## Step 3: Handle Batch Result

Parse the batch executor result and handle based on status:

### Status: SUCCESS

Task completed successfully. Return summary to main work skill:

```json
{
  "status": "SUCCESS",
  "issue_id": "2.1-issue-name",
  "commits": [...],
  "files_changed": 5,
  "tokens_used": 65000,
  "merged": true
}
```

### Status: APPROVAL_REQUIRED

Batch executor paused at approval gate. Handle user approval:

1. Display the task goal from the result
2. Use AskUserQuestion:
   - header: "Approval"
   - question: "Ready to merge {ISSUE_ID}?"
   - options:
     - "Approve and merge"
     - "Request changes" (provide feedback)
     - "Abort"

**If approved:** Spawn merge-only executor to complete Phase 4.

```
Task tool:
  description: "Merge: squash, merge, cleanup"
  subagent_type: "general-purpose"
  model: "haiku"
  prompt: |
    Execute ONLY the merge phase for task ${ISSUE_ID}.

    Output the merging banner first:
    ```
    [Insert merging banner from INDIVIDUAL PHASE BANNERS]
    ```

    Then execute the merge.

    ISSUE_ID: ${ISSUE_ID}
    ISSUE_PATH: ${TASK_PATH}
    WORKTREE_PATH: ${WORKTREE_PATH}
    BRANCH: ${BRANCH}
    BASE_BRANCH: ${BASE_BRANCH}
    COMMITS: ${commits_from_execution}
    AUTO_REMOVE_WORKTREES: ${AUTO_REMOVE}

    Load and follow: @${CLAUDE_PLUGIN_ROOT}/skills/work-merge/SKILL.md

    Return JSON per the output contract.
```

**If changes requested:** Return to user with feedback for iteration.

**If aborted:** Clean up and return ABORTED status.

### Status: FAILED

Display error message and offer options:
- Retry the failed phase
- Abort and cleanup
- Manual intervention

## Error Handling

If batch executor fails unexpectedly:

1. Capture error message
2. Attempt lock release: `${CLAUDE_PLUGIN_ROOT}/scripts/issue-lock.sh release ...`
3. Display error to user
4. Return error status to main work skill

## Return to Main Skill

After handling completes (successfully or with error), return control to the main `/cat:work`
skill so it can check for next tasks and handle auto-continuation.

Return a summary of the execution:

```json
{
  "status": "SUCCESS|FAILED|ABORTED",
  "issue_id": "2.1-issue-name",
  "commits": [...],
  "files_changed": 5,
  "tokens_used": 65000,
  "merged": true
}
```

## Success Criteria

- [ ] Single Task spawn for batch executor (vs 3 separate spawns)
- [ ] Progress banners displayed at phase transitions via text output
- [ ] User approval gate respected (unless trust=high)
- [ ] Lock released on completion or error
- [ ] Results collected and parsed as JSON
